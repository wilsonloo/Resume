<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Coding packages by wilsonloo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Coding packages</h1>
      <h2 class="project-tagline">编程开发使用的套件</h2>
      <a href="https://github.com/wilsonloo/Resume" class="btn">View on GitHub</a>
      <a href="https://github.com/wilsonloo/Resume/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/wilsonloo/Resume/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="以下是个人的代码库描述" class="anchor" href="#%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93%E6%8F%8F%E8%BF%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>以下是个人的代码库描述</h1>

<h2>
<a id="httpsgithubcomwilsonlooyy_idol私有" class="anchor" href="#httpsgithubcomwilsonlooyy_idol%E7%A7%81%E6%9C%89" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/wilsonloo/yy_idol%EF%BC%88%E7%A7%81%E6%9C%89%EF%BC%89">https://github.com/wilsonloo/yy_idol（私有）</a>
</h2>

<p>使用多进程架构的C++ 游戏服务端， 例如有常规的账号服务器、网关服务器、中心服务器、逻辑服务器、数据库服务器。该库有两个分支：</p>

<h4>
<a id="master-分支是在windowns下开发运行版本参考广州要玩的王者屠龙服务器端设计当前处理基础的多进程架构外实现了角色属性活动军团邮件成就战斗技能系统好友系统物品系统任务系统lua脚本嵌入宠物伙伴世界boss-等这些模块的基础代码master分支的设计目标是架构及实现基本的游戏服务端基本框架特点是充分使用了boost进行开发尤其基于是boostasio进行框架的运行例如基于任务列表的多路复用的网络io定时器回调整体逻辑使用单线程开发复杂度较大" class="anchor" href="#master-%E5%88%86%E6%94%AF%E6%98%AF%E5%9C%A8windowns%E4%B8%8B%E5%BC%80%E5%8F%91%E8%BF%90%E8%A1%8C%E7%89%88%E6%9C%AC%E5%8F%82%E8%80%83%E5%B9%BF%E5%B7%9E%E8%A6%81%E7%8E%A9%E7%9A%84%E7%8E%8B%E8%80%85%E5%B1%A0%E9%BE%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AE%BE%E8%AE%A1%E5%BD%93%E5%89%8D%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84%E5%A4%96%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%A7%92%E8%89%B2%E5%B1%9E%E6%80%A7%E6%B4%BB%E5%8A%A8%E5%86%9B%E5%9B%A2%E9%82%AE%E4%BB%B6%E6%88%90%E5%B0%B1%E6%88%98%E6%96%97%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F%E5%A5%BD%E5%8F%8B%E7%B3%BB%E7%BB%9F%E7%89%A9%E5%93%81%E7%B3%BB%E7%BB%9F%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9Flua%E8%84%9A%E6%9C%AC%E5%B5%8C%E5%85%A5%E5%AE%A0%E7%89%A9%E4%BC%99%E4%BC%B4%E4%B8%96%E7%95%8Cboss-%E7%AD%89%E8%BF%99%E4%BA%9B%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81master%E5%88%86%E6%94%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E6%98%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E7%89%B9%E7%82%B9%E6%98%AF%E5%85%85%E5%88%86%E4%BD%BF%E7%94%A8%E4%BA%86boost%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%E5%B0%A4%E5%85%B6%E5%9F%BA%E4%BA%8E%E6%98%AFboostasio%E8%BF%9B%E8%A1%8C%E6%A1%86%E6%9E%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E4%BE%8B%E5%A6%82%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9Cio%E5%AE%9A%E6%97%B6%E5%99%A8%E5%9B%9E%E8%B0%83%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%BE%83%E5%A4%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>master 分支：是在windowns下开发、运行版本，参考广州要玩的《王者屠龙》服务器端设计；当前处理基础的多进程架构外，实现了角色属性、活动、军团、邮件、成就、战斗技能系统、好友系统、物品系统、任务系统、lua脚本嵌入、宠物（伙伴）、世界boss 等这些模块的基础代码；master分支的设计目标是架构及实现基本的游戏服务端基本框架，特点是充分使用了boost进行开发，尤其基于是boost::asio进行框架的运行（例如基于任务列表的多路复用的网络io、定时器回调），整体逻辑使用单线程；开发复杂度较大。</h4>

<h4>
<a id="probuf-based分支从master分支稳定后产生主要用于-广州百田yy-偶像大师项目的具体应用主要有以下几个新的特性" class="anchor" href="#probuf-based%E5%88%86%E6%94%AF%E4%BB%8Emaster%E5%88%86%E6%94%AF%E7%A8%B3%E5%AE%9A%E5%90%8E%E4%BA%A7%E7%94%9F%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E-%E5%B9%BF%E5%B7%9E%E7%99%BE%E7%94%B0yy-%E5%81%B6%E5%83%8F%E5%A4%A7%E5%B8%88%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%E4%B8%BB%E8%A6%81%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>probuf-based分支：从master分支稳定后产生，主要用于 广州百田《YY-偶像大师》项目的具体应用，主要有以下几个新的特性：</h4>

<ol>
<li>采用windows下vs进行开发编写coding，在ubuntu下编译运行（产生这一情况的原因是，随着更多第三方库的引入，windows下的 win_socket.h/windowns.h 的包含问题很是恶心，虽然自己有一套 wrapper.h 可以处理这些文件的包含顺序问题，但是一些第三方库总是要求自己必须被首次include，我当时同时使用了boost::asio、redis、mysql等网络相关的第三方库，经常需要确保头文件包含顺序；后来厌烦了，直接变更开发方式）；</li>
<li>引入redis（master的中心服务器主要有两大工作内容：【消息转发】和【全局消息缓存】，这就产生了单点问题；【消息转发】是无状态服务，挂掉重启即可恢复服务；但是【全局消息缓存】则需要面临数据的可恢复性，而redis本身就是基于内存的消息缓存，还能引入订阅-发布模式、数据落地操作）。redis 在《YY-偶像大师》中有一项实际实现：网关服务器的信息缓存；网关服务器fep是需要进行负载均衡的，随着玩家数量的改变，fep的数量也会动态变更，master分支的做法是由center进行统一管理（复杂度很高，需要维护与各种服务器间的处理）；每次新的fep开放后，都会向redis登记其基本的ip、port 和 玩家数量信息，断开则由center进行删除记录或者在redis上添加超时机制使自动删除；而那些依赖于fep的负载情况进行逻辑处理的服务，如登陆服务器、逻辑服务器，则在启动时从redis拉取这个fep列表、并使用redis的订阅-发布机制监听fep信息的变更。redis的这种机制简化了两个问题：消息缓存 和 基于发布-观察模式的消息处理。</li>
<li>
<p>网络消息协议使用protobuf 和 二进制两种方式并存。
一、服务器内部之间采用二进制方式通信，原因是一般服务器代码维护的都是同一语言、同一帮人，协议多变性较少；
二、与客户端相关的通信，使用protobuf（一个比较大的体会是，《YY-偶像大师》客户端用的是flash，使用二进制方面，他们比较复杂；后来客户同事全体离职后，我用golang开发机器人代替客户端，golang的网络消息协议又得参照master的重写一遍，还有一次是使用UE4-VR在设计一款居家装修效果浏览的客户端，虽然是也是C++，但必须共享master的消息定义头文件）... 也就是说二进制方式比较固定、容易受制于某一框架；使用protobuf后，只需要各种客户端只需要依照消息原形文件 proto进行转换即可，无需进行人员间、编程语言之间沟通耦合。
三、不管使用protobuf 还是 二进制，都需要使用外围进行封装，至少得包含实际逻辑消息的长度；由于使用了混合机制，就进入了标记字段，其中包含以下标记位：<br>
    0                   1                   2                   3<br>
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>
0 |           flags               |        packet length          |<br>
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>
4 |                           typname-len                         |<br>
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>
8 |                           typename-str                        |<br>
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>
? |                              ...                              |<br>
 |                        protobuf message                       |<br>
|                              ...                              |<br>
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br></p>

<p>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
0 |           flags               |        packet length          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
4 |                              ...                              |
 |                           logic message                       |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>

<p>消息有两部分组成：消息头 + 消息体</p>

<p>消息头Header：
其中消息头长度为 4 = sizeof(char) * 4 也就是一个长度为32位 的int
高15位为控制字段:<br>
        PACKET_FLAG_NONE            = 0x00000000,
        PACKET_FLAG_HAS_PROTOBUFF       = 0x40000000, // 实际逻辑包通过 proto buff 打包
        PACKET_FLAG_DYN_PROTOBUFF       = 0x20000000, // 动态protobuf，需要使用protobuf的反射机制处理
        PROTO_LANG_TYPE_CXX             = 0x00020000, // 传输proto 语言（CXX）
        PROTO_LANG_TYPE_GO              = 0x00040000, // 传输proto 语言（golang）
        PROTO_LANG_TYPE_JAVA            = 0x00080000, // 传输proto 语言（JAVA）
低17位为实际消息的长度（可通过 0x1FFFF 掩码获取）
尤其是以后运维时，平台可能通过php进行平台活动的添加，那就使用了protobuf通信，并且消息类型使用字符串，这样就不需要和游戏开发商商量定制消息ID号，并且会设置 PACKET_FLAG_DYN_PROTOBUFF 标记，让游戏内部使用lua脚本进行动态消息的动态处理；
如果消息还需要打包的话，还会添加 PACKET_FLAG_ZIP_ENCODED 标记用表明需要进行压缩解压等等；PACKET_FLAG_HAS_PROTOBUFF 在fep中得到了广泛的引用，因为连接到fep的处理客户端外还有内部的其他服务器，这里就需要根据该标记进行区别处理咯。</p>
</li>
</ol>

<h2>
<a id="httpsgithubcomwilsonloochat_architeture" class="anchor" href="#httpsgithubcomwilsonloochat_architeture" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/wilsonloo/chat_architeture">https://github.com/wilsonloo/chat_architeture</a>
</h2>

<p>基于golang + protobuf + redis 聊天服务器
该项目的设计动机是，充分学习golagn 和 redis的好处。主要表现为
一、golang 是学习成本很低、开发效率很高的语言，其很好的一个特性是 channel 和 协程；channel能够很好地替代c++里的消息队列维护，编写很简单、效率高；而协程则可以很好的分派任务，而不必向c++那样需要特别关注线程的能效，考虑会不会太多线程等。而世界聊天则主要利用redis的发布-订阅机制，只用于世界聊天和跨服聊天，暂不支持小部分玩家间的聊天（因为每次订阅都需要家里新的tcp连接）；订阅的时候是聊天服务器向 聊天数据库redis 订阅本服服务的id，和世界服id，在通过客户端等级的 聊天UDP 端口进行聊天消息发放。
二、另外，golang的修改编译运行效率较高，方便编写了机器人，进行聊天压力测试。
三、添加了简单的开服工具
四、Player 分支，模拟机器人客户端用和 <a href="https://github.com/wilsonloo/yy_idol%EF%BC%88%E7%A7%81%E6%9C%89%EF%BC%89%E8%BF%9B%E8%A1%8C%E9%80%BB%E8%BE%91%E6%B5%8B%E8%AF%95%EF%BC%9B">https://github.com/wilsonloo/yy_idol（私有）进行逻辑测试；</a>
五、设计图：
<img src="http://www.wilson-loo.com/wordpress/wp-content/uploads/2016/07/%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1.jpg" alt="聊天服务器设计"></p>

<h2>
<a id="httpsgithubcomwilsonlooutility私有" class="anchor" href="#httpsgithubcomwilsonlooutility%E7%A7%81%E6%9C%89" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/wilsonloo/utility%EF%BC%88%E7%A7%81%E6%9C%89%EF%BC%89">https://github.com/wilsonloo/utility（私有）</a>
</h2>

<p>个人辅助工具：
auto_link.h              windowns下自动链接对应库服辅助类（参考自boost的库自动链接）
bitmap_recorder.hpp      位图（位大小可为一位或一个字节）
console.hpp              终端输入处理，将输入的数值用std::vector 维护，由客户提供线程进行驱动
data_dump.hpp            内存数据可视化显示
fixed_size_object_pool.h 固定大小的对象池
message_block.hpp        消息块
message_queue.hpp        基于message_block 的消息队列
mini_dump.h              windowns下的core dump 生成工具
read_write_array.hpp     读写队列（双缓冲池）
singleton.hpp            单体模板
task_base.hpp            任务队列
uuid_generator.hpp       uuid 生成器
varlen_struct.hpp        边长结构体
winsock_wrapper.h        windowns下的 winsock(2).h 与 windowns.h 的包含顺序辅助</p>

<h2>
<a id="httpsgithubcomwilsonlooevl_net" class="anchor" href="#httpsgithubcomwilsonlooevl_net" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/wilsonloo/evl_net">https://github.com/wilsonloo/evl_net</a>
</h2>

<p>基于boost::asio 的网络库</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/wilsonloo/Resume">Coding packages</a> is maintained by <a href="https://github.com/wilsonloo">wilsonloo</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
